{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { BehaviorSubject, Observable, Subject } from 'rxjs';\nimport { filter, share, take } from 'rxjs/operators';\nimport { Client } from '@stomp/stompjs';\nimport { RxStompState } from './rx-stomp-state';\n/**\n * This is the main Stomp Client.\n * Typically you will create an instance of this to connect to the STOMP broker.\n *\n * This wraps [@stomp/stompjs]{@link https://github.com/stomp-js/stompjs}\n * {@link Client} class.\n *\n * The key difference is that it exposes operations as RxJS Observables.\n * For example when a STOMP endpoint is subscribed it returns an Observable\n * that will stream all received messages.\n *\n * With exception of beforeConnect, functionality related to all callbacks in\n * [@stomp/stompjs Client]{@link Client}\n * is exposed as Observables/Subjects/BehaviorSubjects.\n *\n * RxStomp also tries to transparently handle connection failures.\n *\n * Part of `@stomp/rx-stomp`\n */\nexport class RxStomp {\n  /**\n   * Constructor\n   *\n   * @param stompClient optionally inject the\n   * [@stomp/stompjs]{@link https://github.com/stomp-js/stompjs}\n   * {@link Client} to wrap. If this is not provided, a client will\n   * be constructed internally.\n   */\n  constructor(stompClient) {\n    /**\n     * Internal array to hold locally queued messages when STOMP broker is not connected.\n     */\n    this._queuedMessages = [];\n    const client = stompClient ? stompClient : new Client();\n    this._stompClient = client;\n    const noOp = () => {};\n    // Before connect is no op by default\n    this._beforeConnect = noOp;\n    // Correlate errors is falsey op by default\n    this._correlateErrors = () => undefined;\n    // debug is no-op by default\n    this._debug = noOp;\n    // Initial state is CLOSED\n    this._connectionStatePre$ = new BehaviorSubject(RxStompState.CLOSED);\n    this._connectedPre$ = this._connectionStatePre$.pipe(filter(currentState => {\n      return currentState === RxStompState.OPEN;\n    }));\n    // Initial state is CLOSED\n    this.connectionState$ = new BehaviorSubject(RxStompState.CLOSED);\n    this.connected$ = this.connectionState$.pipe(filter(currentState => {\n      return currentState === RxStompState.OPEN;\n    }));\n    // Setup sending queuedMessages\n    this.connected$.subscribe(() => {\n      this._sendQueuedMessages();\n    });\n    this._serverHeadersBehaviourSubject$ = new BehaviorSubject(null);\n    this.serverHeaders$ = this._serverHeadersBehaviourSubject$.pipe(filter(headers => {\n      return headers !== null;\n    }));\n    this.stompErrors$ = new Subject();\n    this.unhandledMessage$ = new Subject();\n    this.unhandledReceipts$ = new Subject();\n    this.unhandledFrame$ = new Subject();\n    this.webSocketErrors$ = new Subject();\n  }\n  /**\n   * Instance of actual\n   * [@stomp/stompjs]{@link https://github.com/stomp-js/stompjs}\n   * {@link Client}.\n   *\n   * **Be careful in calling methods on it directly - you may get unintended consequences.**\n   */\n  get stompClient() {\n    return this._stompClient;\n  }\n  /**\n   * Set configuration. This method may be called multiple times.\n   * Each call will add to the existing configuration.\n   *\n   * Example:\n   *\n   * ```javascript\n   *        const rxStomp = new RxStomp();\n   *        rxStomp.configure({\n   *          brokerURL: 'ws://127.0.0.1:15674/ws',\n   *          connectHeaders: {\n   *            login: 'guest',\n   *            passcode: 'guest'\n   *          },\n   *          heartbeatIncoming: 0,\n   *          heartbeatOutgoing: 20000,\n   *          reconnectDelay: 200,\n   *          debug: (msg: string): void => {\n   *            console.log(new Date(), msg);\n   *          }\n   *        });\n   *        rxStomp.activate();\n   * ```\n   *\n   * Maps to: [Client#configure]{@link Client#configure}\n   */\n  configure(rxStompConfig) {\n    const stompConfig = Object.assign({}, rxStompConfig);\n    if (stompConfig.beforeConnect) {\n      this._beforeConnect = stompConfig.beforeConnect;\n      delete stompConfig.beforeConnect;\n    }\n    if (stompConfig.correlateErrors) {\n      this._correlateErrors = stompConfig.correlateErrors;\n      delete stompConfig.correlateErrors;\n    }\n    // RxStompConfig has subset of StompConfig fields\n    this._stompClient.configure(stompConfig);\n    if (stompConfig.debug) {\n      this._debug = stompConfig.debug;\n    }\n  }\n  /**\n   * Initiate the connection with the broker.\n   * If the connection breaks, as per [RxStompConfig#reconnectDelay]{@link RxStompConfig#reconnectDelay},\n   * it will keep trying to reconnect.\n   *\n   * Call [RxStomp#deactivate]{@link RxStomp#deactivate} to disconnect and stop reconnection attempts.\n   *\n   * Maps to: [Client#activate]{@link Client#activate}\n   */\n  activate() {\n    this._stompClient.configure({\n      beforeConnect: () => __awaiter(this, void 0, void 0, function* () {\n        this._changeState(RxStompState.CONNECTING);\n        // Call handler\n        yield this._beforeConnect(this);\n      }),\n      onConnect: frame => {\n        this._serverHeadersBehaviourSubject$.next(frame.headers);\n        // Indicate our connected state to observers\n        this._changeState(RxStompState.OPEN);\n      },\n      onStompError: frame => {\n        // Trigger the frame subject\n        this.stompErrors$.next(frame);\n      },\n      onWebSocketClose: () => {\n        this._changeState(RxStompState.CLOSED);\n      },\n      onUnhandledMessage: message => {\n        this.unhandledMessage$.next(message);\n      },\n      onUnhandledReceipt: frame => {\n        this.unhandledReceipts$.next(frame);\n      },\n      onUnhandledFrame: frame => {\n        this.unhandledFrame$.next(frame);\n      },\n      onWebSocketError: evt => {\n        this.webSocketErrors$.next(evt);\n      }\n    });\n    // Attempt connection\n    this._stompClient.activate();\n  }\n  /**\n   * Disconnect if connected and stop auto reconnect loop.\n   * Appropriate callbacks will be invoked if underlying STOMP connection was connected.\n   *\n   * To reactivate you can call [RxStomp#activate]{@link RxStomp#activate}.\n   *\n   * Maps to: [Client#deactivate]{@link Client#deactivate}\n   */\n  deactivate() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this._changeState(RxStompState.CLOSING);\n      // The promise will be resolved immediately if there are no active connection\n      // otherwise, after it has successfully disconnected.\n      yield this._stompClient.deactivate();\n      this._changeState(RxStompState.CLOSED);\n    });\n  }\n  /**\n   * It will return `true` if STOMP broker is connected and `false` otherwise.\n   */\n  connected() {\n    return this.connectionState$.getValue() === RxStompState.OPEN;\n  }\n  /**\n   * If the client is active (connected or going to reconnect).\n   *\n   *  Maps to: [Client#active]{@link Client#active}\n   */\n  get active() {\n    return this.stompClient.active;\n  }\n  /**\n   * Send a message to a named destination. Refer to your STOMP broker documentation for types\n   * and naming of destinations.\n   *\n   * STOMP protocol specifies and suggests some headers and also allows broker specific headers.\n   *\n   * `body` must be String.\n   * You will need to covert the payload to string in case it is not string (e.g. JSON).\n   *\n   * To send a binary message body use binaryBody parameter. It should be a\n   * [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array).\n   * Sometimes brokers may not support binary frames out of the box.\n   * Please check your broker documentation.\n   *\n   * `content-length` header is automatically added to the STOMP Frame sent to the broker.\n   * Set `skipContentLengthHeader` to indicate that `content-length` header should not be added.\n   * For binary messages `content-length` header is always added.\n   *\n   * Caution: The broker will, most likely, report an error and disconnect if message body has NULL octet(s)\n   * and `content-length` header is missing.\n   *\n   * The message will get locally queued if the STOMP broker is not connected. It will attempt to\n   * publish queued messages as soon as the broker gets connected.\n   * If you do not want that behavior,\n   * please set [retryIfDisconnected]{@link IRxStompPublishParams#retryIfDisconnected} to `false`\n   * in the parameters.\n   * When `false`, this function will raise an error if message could not be sent immediately.\n   *\n   * Maps to: [Client#publish]{@link Client#publish}\n   *\n   * See: {@link IRxStompPublishParams} and {@link IPublishParams}\n   *\n   * ```javascript\n   *        rxStomp.publish({destination: \"/queue/test\", headers: {priority: 9}, body: \"Hello, STOMP\"});\n   *\n   *        // Only destination is mandatory parameter\n   *        rxStomp.publish({destination: \"/queue/test\", body: \"Hello, STOMP\"});\n   *\n   *        // Skip content-length header in the frame to the broker\n   *        rxStomp.publish({\"/queue/test\", body: \"Hello, STOMP\", skipContentLengthHeader: true});\n   *\n   *        var binaryData = generateBinaryData(); // This need to be of type Uint8Array\n   *        // setting content-type header is not mandatory, however a good practice\n   *        rxStomp.publish({destination: '/topic/special', binaryBody: binaryData,\n   *                         headers: {'content-type': 'application/octet-stream'}});\n   * ```\n   */\n  publish(parameters) {\n    // retry behaviour is defaulted to true\n    const shouldRetry = parameters.retryIfDisconnected == null ? true : parameters.retryIfDisconnected;\n    if (this.connected()) {\n      this._stompClient.publish(parameters);\n    } else if (shouldRetry) {\n      this._debug(`Not connected, queueing`);\n      this._queuedMessages.push(parameters);\n    } else {\n      throw new Error('Cannot publish while broker is not connected');\n    }\n  }\n  /** It will send queued messages. */\n  _sendQueuedMessages() {\n    const queuedMessages = this._queuedMessages;\n    this._queuedMessages = [];\n    if (queuedMessages.length === 0) {\n      return;\n    }\n    this._debug(`Will try sending  ${queuedMessages.length} queued message(s)`);\n    for (const queuedMessage of queuedMessages) {\n      this._debug(`Attempting to send ${queuedMessage}`);\n      this.publish(queuedMessage);\n    }\n  }\n  watch(opts, headers = {}) {\n    const defaults = {\n      subHeaders: {},\n      unsubHeaders: {},\n      subscribeOnlyOnce: false\n    };\n    let params;\n    if (typeof opts === 'string') {\n      params = Object.assign({}, defaults, {\n        destination: opts,\n        subHeaders: headers\n      });\n    } else {\n      params = Object.assign({}, defaults, opts);\n    }\n    /* Well the logic is complicated but works beautifully. RxJS is indeed wonderful.\n     *\n     * We need to activate the underlying subscription immediately if Stomp is connected. If not it should\n     * subscribe when it gets next connected. Further it should re establish the subscription whenever Stomp\n     * successfully reconnects.\n     *\n     * Actual implementation is simple, we filter the BehaviourSubject 'state' so that we can trigger whenever Stomp is\n     * connected. Since 'state' is a BehaviourSubject, if Stomp is already connected, it will immediately trigger.\n     *\n     * The observable that we return to caller remains same across all reconnects, so no special handling needed at\n     * the message subscriber.\n     */\n    this._debug(`Request to subscribe ${params.destination}`);\n    const coldObservable = Observable.create(messages => {\n      /*\n       * These variables will be used as part of the closure and work their magic during unsubscribe\n       */\n      let stompSubscription; // Stomp\n      let stompConnectedSubscription; // RxJS\n      let connectedPre$ = this._connectedPre$;\n      if (params.subscribeOnlyOnce) {\n        connectedPre$ = connectedPre$.pipe(take(1));\n      }\n      const stompErrorsSubscription = this.stompErrors$.subscribe(error => {\n        const correlatedDestination = this._correlateErrors(error);\n        if (correlatedDestination === params.destination) {\n          messages.error(error);\n        }\n      });\n      stompConnectedSubscription = connectedPre$.subscribe(() => {\n        this._debug(`Will subscribe to ${params.destination}`);\n        let subHeaders = params.subHeaders;\n        if (typeof subHeaders === 'function') {\n          subHeaders = subHeaders();\n        }\n        stompSubscription = this._stompClient.subscribe(params.destination, message => {\n          messages.next(message);\n        }, subHeaders);\n      });\n      return () => {\n        /* cleanup function, will be called when no subscribers are left */\n        this._debug(`Stop watching connection state (for ${params.destination})`);\n        stompConnectedSubscription.unsubscribe();\n        stompErrorsSubscription.unsubscribe();\n        if (this.connected()) {\n          this._debug(`Will unsubscribe from ${params.destination} at Stomp`);\n          let unsubHeaders = params.unsubHeaders;\n          if (typeof unsubHeaders === 'function') {\n            unsubHeaders = unsubHeaders();\n          }\n          stompSubscription.unsubscribe(unsubHeaders);\n        } else {\n          this._debug(`Stomp not connected, no need to unsubscribe from ${params.destination} at Stomp`);\n        }\n      };\n    });\n    /**\n     * Important - convert it to hot Observable - otherwise, if the user code subscribes\n     * to this observable twice, it will subscribe twice to Stomp broker. (This was happening in the current example).\n     * A long but good explanatory article at https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339\n     */\n    return coldObservable.pipe(share());\n  }\n  /**\n   * STOMP brokers may carry out operation asynchronously and allow requesting for acknowledgement.\n   * To request an acknowledgement, a `receipt` header needs to be sent with the actual request.\n   * The value (say receipt-id) for this header needs to be unique for each use. Typically a sequence, a UUID, a\n   * random number or a combination may be used.\n   *\n   * A complaint broker will send a RECEIPT frame when an operation has actually been completed.\n   * The operation needs to be matched based in the value of the receipt-id.\n   *\n   * This method allow watching for a receipt and invoke the callback\n   * when corresponding receipt has been received.\n   *\n   * The actual {@link Frame}\n   * will be passed as parameter to the callback.\n   *\n   * Example:\n   * ```javascript\n   *        // Publishing with acknowledgement\n   *        let receiptId = randomText();\n   *\n   *        rxStomp.watchForReceipt(receiptId, function() {\n   *          // Will be called after server acknowledges\n   *        });\n   *        rxStomp.publish({destination: '/topic/special', headers: {receipt: receiptId}, body: msg});\n   * ```\n   *\n   * Maps to: [Client#watchForReceipt]{@link Client#watchForReceipt}\n   */\n  watchForReceipt(receiptId, callback) {\n    this._stompClient.watchForReceipt(receiptId, callback);\n  }\n  _changeState(state) {\n    this._connectionStatePre$.next(state);\n    this.connectionState$.next(state);\n  }\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","BehaviorSubject","Observable","Subject","filter","share","take","Client","RxStompState","RxStomp","constructor","stompClient","_queuedMessages","client","_stompClient","noOp","_beforeConnect","_correlateErrors","undefined","_debug","_connectionStatePre$","CLOSED","_connectedPre$","pipe","currentState","OPEN","connectionState$","connected$","subscribe","_sendQueuedMessages","_serverHeadersBehaviourSubject$","serverHeaders$","headers","stompErrors$","unhandledMessage$","unhandledReceipts$","unhandledFrame$","webSocketErrors$","configure","rxStompConfig","stompConfig","Object","assign","beforeConnect","correlateErrors","debug","activate","_changeState","CONNECTING","onConnect","frame","onStompError","onWebSocketClose","onUnhandledMessage","message","onUnhandledReceipt","onUnhandledFrame","onWebSocketError","evt","deactivate","CLOSING","connected","getValue","active","publish","parameters","shouldRetry","retryIfDisconnected","push","Error","queuedMessages","length","queuedMessage","watch","opts","defaults","subHeaders","unsubHeaders","subscribeOnlyOnce","params","destination","coldObservable","create","messages","stompSubscription","stompConnectedSubscription","connectedPre$","stompErrorsSubscription","error","correlatedDestination","unsubscribe","watchForReceipt","receiptId","callback","state"],"sources":["C:/Users/hp/coChat/node_modules/@stomp/rx-stomp/esm6/rx-stomp.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BehaviorSubject, Observable, Subject, } from 'rxjs';\nimport { filter, share, take } from 'rxjs/operators';\nimport { Client, } from '@stomp/stompjs';\nimport { RxStompState } from './rx-stomp-state';\n/**\n * This is the main Stomp Client.\n * Typically you will create an instance of this to connect to the STOMP broker.\n *\n * This wraps [@stomp/stompjs]{@link https://github.com/stomp-js/stompjs}\n * {@link Client} class.\n *\n * The key difference is that it exposes operations as RxJS Observables.\n * For example when a STOMP endpoint is subscribed it returns an Observable\n * that will stream all received messages.\n *\n * With exception of beforeConnect, functionality related to all callbacks in\n * [@stomp/stompjs Client]{@link Client}\n * is exposed as Observables/Subjects/BehaviorSubjects.\n *\n * RxStomp also tries to transparently handle connection failures.\n *\n * Part of `@stomp/rx-stomp`\n */\nexport class RxStomp {\n    /**\n     * Constructor\n     *\n     * @param stompClient optionally inject the\n     * [@stomp/stompjs]{@link https://github.com/stomp-js/stompjs}\n     * {@link Client} to wrap. If this is not provided, a client will\n     * be constructed internally.\n     */\n    constructor(stompClient) {\n        /**\n         * Internal array to hold locally queued messages when STOMP broker is not connected.\n         */\n        this._queuedMessages = [];\n        const client = stompClient ? stompClient : new Client();\n        this._stompClient = client;\n        const noOp = () => { };\n        // Before connect is no op by default\n        this._beforeConnect = noOp;\n        // Correlate errors is falsey op by default\n        this._correlateErrors = () => undefined;\n        // debug is no-op by default\n        this._debug = noOp;\n        // Initial state is CLOSED\n        this._connectionStatePre$ = new BehaviorSubject(RxStompState.CLOSED);\n        this._connectedPre$ = this._connectionStatePre$.pipe(filter((currentState) => {\n            return currentState === RxStompState.OPEN;\n        }));\n        // Initial state is CLOSED\n        this.connectionState$ = new BehaviorSubject(RxStompState.CLOSED);\n        this.connected$ = this.connectionState$.pipe(filter((currentState) => {\n            return currentState === RxStompState.OPEN;\n        }));\n        // Setup sending queuedMessages\n        this.connected$.subscribe(() => {\n            this._sendQueuedMessages();\n        });\n        this._serverHeadersBehaviourSubject$ =\n            new BehaviorSubject(null);\n        this.serverHeaders$ = this._serverHeadersBehaviourSubject$.pipe(filter((headers) => {\n            return headers !== null;\n        }));\n        this.stompErrors$ = new Subject();\n        this.unhandledMessage$ = new Subject();\n        this.unhandledReceipts$ = new Subject();\n        this.unhandledFrame$ = new Subject();\n        this.webSocketErrors$ = new Subject();\n    }\n    /**\n     * Instance of actual\n     * [@stomp/stompjs]{@link https://github.com/stomp-js/stompjs}\n     * {@link Client}.\n     *\n     * **Be careful in calling methods on it directly - you may get unintended consequences.**\n     */\n    get stompClient() {\n        return this._stompClient;\n    }\n    /**\n     * Set configuration. This method may be called multiple times.\n     * Each call will add to the existing configuration.\n     *\n     * Example:\n     *\n     * ```javascript\n     *        const rxStomp = new RxStomp();\n     *        rxStomp.configure({\n     *          brokerURL: 'ws://127.0.0.1:15674/ws',\n     *          connectHeaders: {\n     *            login: 'guest',\n     *            passcode: 'guest'\n     *          },\n     *          heartbeatIncoming: 0,\n     *          heartbeatOutgoing: 20000,\n     *          reconnectDelay: 200,\n     *          debug: (msg: string): void => {\n     *            console.log(new Date(), msg);\n     *          }\n     *        });\n     *        rxStomp.activate();\n     * ```\n     *\n     * Maps to: [Client#configure]{@link Client#configure}\n     */\n    configure(rxStompConfig) {\n        const stompConfig = Object.assign({}, rxStompConfig);\n        if (stompConfig.beforeConnect) {\n            this._beforeConnect = stompConfig.beforeConnect;\n            delete stompConfig.beforeConnect;\n        }\n        if (stompConfig.correlateErrors) {\n            this._correlateErrors = stompConfig.correlateErrors;\n            delete stompConfig.correlateErrors;\n        }\n        // RxStompConfig has subset of StompConfig fields\n        this._stompClient.configure(stompConfig);\n        if (stompConfig.debug) {\n            this._debug = stompConfig.debug;\n        }\n    }\n    /**\n     * Initiate the connection with the broker.\n     * If the connection breaks, as per [RxStompConfig#reconnectDelay]{@link RxStompConfig#reconnectDelay},\n     * it will keep trying to reconnect.\n     *\n     * Call [RxStomp#deactivate]{@link RxStomp#deactivate} to disconnect and stop reconnection attempts.\n     *\n     * Maps to: [Client#activate]{@link Client#activate}\n     */\n    activate() {\n        this._stompClient.configure({\n            beforeConnect: () => __awaiter(this, void 0, void 0, function* () {\n                this._changeState(RxStompState.CONNECTING);\n                // Call handler\n                yield this._beforeConnect(this);\n            }),\n            onConnect: (frame) => {\n                this._serverHeadersBehaviourSubject$.next(frame.headers);\n                // Indicate our connected state to observers\n                this._changeState(RxStompState.OPEN);\n            },\n            onStompError: (frame) => {\n                // Trigger the frame subject\n                this.stompErrors$.next(frame);\n            },\n            onWebSocketClose: () => {\n                this._changeState(RxStompState.CLOSED);\n            },\n            onUnhandledMessage: (message) => {\n                this.unhandledMessage$.next(message);\n            },\n            onUnhandledReceipt: (frame) => {\n                this.unhandledReceipts$.next(frame);\n            },\n            onUnhandledFrame: (frame) => {\n                this.unhandledFrame$.next(frame);\n            },\n            onWebSocketError: (evt) => {\n                this.webSocketErrors$.next(evt);\n            },\n        });\n        // Attempt connection\n        this._stompClient.activate();\n    }\n    /**\n     * Disconnect if connected and stop auto reconnect loop.\n     * Appropriate callbacks will be invoked if underlying STOMP connection was connected.\n     *\n     * To reactivate you can call [RxStomp#activate]{@link RxStomp#activate}.\n     *\n     * Maps to: [Client#deactivate]{@link Client#deactivate}\n     */\n    deactivate() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._changeState(RxStompState.CLOSING);\n            // The promise will be resolved immediately if there are no active connection\n            // otherwise, after it has successfully disconnected.\n            yield this._stompClient.deactivate();\n            this._changeState(RxStompState.CLOSED);\n        });\n    }\n    /**\n     * It will return `true` if STOMP broker is connected and `false` otherwise.\n     */\n    connected() {\n        return this.connectionState$.getValue() === RxStompState.OPEN;\n    }\n    /**\n     * If the client is active (connected or going to reconnect).\n     *\n     *  Maps to: [Client#active]{@link Client#active}\n     */\n    get active() {\n        return this.stompClient.active;\n    }\n    /**\n     * Send a message to a named destination. Refer to your STOMP broker documentation for types\n     * and naming of destinations.\n     *\n     * STOMP protocol specifies and suggests some headers and also allows broker specific headers.\n     *\n     * `body` must be String.\n     * You will need to covert the payload to string in case it is not string (e.g. JSON).\n     *\n     * To send a binary message body use binaryBody parameter. It should be a\n     * [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array).\n     * Sometimes brokers may not support binary frames out of the box.\n     * Please check your broker documentation.\n     *\n     * `content-length` header is automatically added to the STOMP Frame sent to the broker.\n     * Set `skipContentLengthHeader` to indicate that `content-length` header should not be added.\n     * For binary messages `content-length` header is always added.\n     *\n     * Caution: The broker will, most likely, report an error and disconnect if message body has NULL octet(s)\n     * and `content-length` header is missing.\n     *\n     * The message will get locally queued if the STOMP broker is not connected. It will attempt to\n     * publish queued messages as soon as the broker gets connected.\n     * If you do not want that behavior,\n     * please set [retryIfDisconnected]{@link IRxStompPublishParams#retryIfDisconnected} to `false`\n     * in the parameters.\n     * When `false`, this function will raise an error if message could not be sent immediately.\n     *\n     * Maps to: [Client#publish]{@link Client#publish}\n     *\n     * See: {@link IRxStompPublishParams} and {@link IPublishParams}\n     *\n     * ```javascript\n     *        rxStomp.publish({destination: \"/queue/test\", headers: {priority: 9}, body: \"Hello, STOMP\"});\n     *\n     *        // Only destination is mandatory parameter\n     *        rxStomp.publish({destination: \"/queue/test\", body: \"Hello, STOMP\"});\n     *\n     *        // Skip content-length header in the frame to the broker\n     *        rxStomp.publish({\"/queue/test\", body: \"Hello, STOMP\", skipContentLengthHeader: true});\n     *\n     *        var binaryData = generateBinaryData(); // This need to be of type Uint8Array\n     *        // setting content-type header is not mandatory, however a good practice\n     *        rxStomp.publish({destination: '/topic/special', binaryBody: binaryData,\n     *                         headers: {'content-type': 'application/octet-stream'}});\n     * ```\n     */\n    publish(parameters) {\n        // retry behaviour is defaulted to true\n        const shouldRetry = parameters.retryIfDisconnected == null\n            ? true\n            : parameters.retryIfDisconnected;\n        if (this.connected()) {\n            this._stompClient.publish(parameters);\n        }\n        else if (shouldRetry) {\n            this._debug(`Not connected, queueing`);\n            this._queuedMessages.push(parameters);\n        }\n        else {\n            throw new Error('Cannot publish while broker is not connected');\n        }\n    }\n    /** It will send queued messages. */\n    _sendQueuedMessages() {\n        const queuedMessages = this._queuedMessages;\n        this._queuedMessages = [];\n        if (queuedMessages.length === 0) {\n            return;\n        }\n        this._debug(`Will try sending  ${queuedMessages.length} queued message(s)`);\n        for (const queuedMessage of queuedMessages) {\n            this._debug(`Attempting to send ${queuedMessage}`);\n            this.publish(queuedMessage);\n        }\n    }\n    watch(opts, headers = {}) {\n        const defaults = {\n            subHeaders: {},\n            unsubHeaders: {},\n            subscribeOnlyOnce: false,\n        };\n        let params;\n        if (typeof opts === 'string') {\n            params = Object.assign({}, defaults, {\n                destination: opts,\n                subHeaders: headers,\n            });\n        }\n        else {\n            params = Object.assign({}, defaults, opts);\n        }\n        /* Well the logic is complicated but works beautifully. RxJS is indeed wonderful.\n         *\n         * We need to activate the underlying subscription immediately if Stomp is connected. If not it should\n         * subscribe when it gets next connected. Further it should re establish the subscription whenever Stomp\n         * successfully reconnects.\n         *\n         * Actual implementation is simple, we filter the BehaviourSubject 'state' so that we can trigger whenever Stomp is\n         * connected. Since 'state' is a BehaviourSubject, if Stomp is already connected, it will immediately trigger.\n         *\n         * The observable that we return to caller remains same across all reconnects, so no special handling needed at\n         * the message subscriber.\n         */\n        this._debug(`Request to subscribe ${params.destination}`);\n        const coldObservable = Observable.create((messages) => {\n            /*\n             * These variables will be used as part of the closure and work their magic during unsubscribe\n             */\n            let stompSubscription; // Stomp\n            let stompConnectedSubscription; // RxJS\n            let connectedPre$ = this._connectedPre$;\n            if (params.subscribeOnlyOnce) {\n                connectedPre$ = connectedPre$.pipe(take(1));\n            }\n            const stompErrorsSubscription = this.stompErrors$.subscribe((error) => {\n                const correlatedDestination = this._correlateErrors(error);\n                if (correlatedDestination === params.destination) {\n                    messages.error(error);\n                }\n            });\n            stompConnectedSubscription = connectedPre$.subscribe(() => {\n                this._debug(`Will subscribe to ${params.destination}`);\n                let subHeaders = params.subHeaders;\n                if (typeof subHeaders === 'function') {\n                    subHeaders = subHeaders();\n                }\n                stompSubscription = this._stompClient.subscribe(params.destination, (message) => {\n                    messages.next(message);\n                }, subHeaders);\n            });\n            return () => {\n                /* cleanup function, will be called when no subscribers are left */\n                this._debug(`Stop watching connection state (for ${params.destination})`);\n                stompConnectedSubscription.unsubscribe();\n                stompErrorsSubscription.unsubscribe();\n                if (this.connected()) {\n                    this._debug(`Will unsubscribe from ${params.destination} at Stomp`);\n                    let unsubHeaders = params.unsubHeaders;\n                    if (typeof unsubHeaders === 'function') {\n                        unsubHeaders = unsubHeaders();\n                    }\n                    stompSubscription.unsubscribe(unsubHeaders);\n                }\n                else {\n                    this._debug(`Stomp not connected, no need to unsubscribe from ${params.destination} at Stomp`);\n                }\n            };\n        });\n        /**\n         * Important - convert it to hot Observable - otherwise, if the user code subscribes\n         * to this observable twice, it will subscribe twice to Stomp broker. (This was happening in the current example).\n         * A long but good explanatory article at https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339\n         */\n        return coldObservable.pipe(share());\n    }\n    /**\n     * STOMP brokers may carry out operation asynchronously and allow requesting for acknowledgement.\n     * To request an acknowledgement, a `receipt` header needs to be sent with the actual request.\n     * The value (say receipt-id) for this header needs to be unique for each use. Typically a sequence, a UUID, a\n     * random number or a combination may be used.\n     *\n     * A complaint broker will send a RECEIPT frame when an operation has actually been completed.\n     * The operation needs to be matched based in the value of the receipt-id.\n     *\n     * This method allow watching for a receipt and invoke the callback\n     * when corresponding receipt has been received.\n     *\n     * The actual {@link Frame}\n     * will be passed as parameter to the callback.\n     *\n     * Example:\n     * ```javascript\n     *        // Publishing with acknowledgement\n     *        let receiptId = randomText();\n     *\n     *        rxStomp.watchForReceipt(receiptId, function() {\n     *          // Will be called after server acknowledges\n     *        });\n     *        rxStomp.publish({destination: '/topic/special', headers: {receipt: receiptId}, body: msg});\n     * ```\n     *\n     * Maps to: [Client#watchForReceipt]{@link Client#watchForReceipt}\n     */\n    watchForReceipt(receiptId, callback) {\n        this._stompClient.watchForReceipt(receiptId, callback);\n    }\n    _changeState(state) {\n        this._connectionStatePre$.next(state);\n        this.connectionState$.next(state);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}